// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: licensor.sql

package sqlc

import (
	"context"
	"database/sql"
	"strings"
)

const getOrganizations = `-- name: GetOrganizations :many

SELECT 
    distinct bfco.organization_id,
    o.slug as organization_slug,
    ot.name as organization_name, ol.url as organization_logo_url
FROM bible_fileset_copyright_organizations as bfco
JOIN organizations o ON o.id = bfco.organization_id
INNER JOIN organization_translations ot ON ot.organization_id = o.id
LEFT JOIN organization_logos ol ON ol.organization_id = o.id AND ol.icon IS FALSE
WHERE bfco.organization_id IN (/*SLICE:organizationsId*/?)
AND ot.language_id = 6414
ORDER BY organization_name
`

type GetOrganizationsRow struct {
	OrganizationID      uint32         `json:"organization_id"`
	OrganizationSlug    string         `json:"organization_slug"`
	OrganizationName    string         `json:"organization_name"`
	OrganizationLogoUrl sql.NullString `json:"organization_logo_url"`
}

func (q *Queries) GetOrganizations(ctx context.Context, organizationsid []uint32) ([]GetOrganizationsRow, error) {
	query := getOrganizations
	var queryParams []interface{}
	if len(organizationsid) > 0 {
		for _, v := range organizationsid {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:organizationsId*/?", strings.Repeat(",?", len(organizationsid))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:organizationsId*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrganizationsRow
	for rows.Next() {
		var i GetOrganizationsRow
		if err := rows.Scan(
			&i.OrganizationID,
			&i.OrganizationSlug,
			&i.OrganizationName,
			&i.OrganizationLogoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
